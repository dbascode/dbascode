# DbAsCode
### Database As Code

A tool to manage database structure "as code" in `yaml` config files, allowing easy VCS storage, changes 
tracking, and automation. The main goal is to manage the structure. Data migrations (by using custom 
migrations) are also supported.

## Goals

This project is aiming to solve the following problems in database lifetime support:

- Having the full human-readable DB structure at any point in time (commit). In conventional migration systems,
you can not see the structure until you connect to a physical DB instance with all the migrations applied. 
Or you have to export the SQL structure manually. You also unable to know the exact structure "N days/months ago"
without applying all the migrations sequentially.
- Changes tracking. You can easily compare Yaml configuration files between commits and 
clearly understand what the exact changes were made. In conventional migration systems, you can not do that without 
special workarounds on exporting SQL DB structure on each build and store it somewhere. Or you have to 
deploy backups on live DB servers.
- Convenient changes comparison. Raw SQL migrations or structure dumps, as well as XML files are 
not so convenient to read change diffs. With Yaml, you will see only those changed lines, 
which actually have changed something in the DB.

### Why not Liquibase or Flyway?   

- Liquibase requires to describe migrations manually. You just move conventional old-style SQL migrations  
to another syntax (XML or Yaml). It doesn't solve any problems mentioned above.
- Flyway operates with SQL migrations. The same, it does some automation but still doesn't work for our goals.

### Why not an ORM with migrations?

ORMs with migrations support can be used to achieve our goals, but there are cases when we don't need their main 
functionality - object relations mapping used in some code. DbAsCode is focusing on describing DB structure without any 
relations to programming languages and data models.

## Project State

This project is currently in a very early development stage. It is not recommended to use it in production.

## Supported Database Types

Currently, only PostgreSQL is supported. Other DBMS support should arrive in the future.

## Installation

Using NPM:
```shell script
$ npm i dbascode
```

Using Yarn:
```shell script
$ yarn add dbascode
```

Install PostgreSQL client:

```shell script
$ apt-get install postgresql-client
```

You also can use the pre-configured Docker image. See Docker documentation if you're not yet familiar with it. 

## Usage

Running with NPM:
```shell script
$ npm run dbascode
```

Running with Yarn:
```shell script
$ yarn dbascode
```

Running with Docker:
```shell script
$ docker run pgascode
```

### Command line options

CLI syntax:

```shell script
$ dbascode <command> [options]
```

#### Commands

- `plan <source> [options]`<br> Compare old and new states and create a migration plan. The new state is read from the `source` file path. If the `---output` option specified, creates the plan file to be used for migration. DbAsCode will print changes in human-readable format to `stdout`. You can redirect the output to a file and save it as an artifact during CI/CD.
- `migrate [options]`<br> Performs migration. Either `--plan` or `--migration` options must be specified for migration. If a plan is specified, pgascode will read SQL queries to execute from it. If another migration was performed since the state file creation, the migration will fail. If a source is specified, pgascode will generate a migration plan and execute it immediately.

#### Options

- `--help`<br> Display CLI help.
- `--version`<br> Display the tool version.
- `--db-var`<br> Database configuration parameter (see particular DB plugin documentation). Multiple options are allowed. 
  <br>Example:
  - `--db-var host=db.id.ap-northeast-1.rds.amazonaws.com --db-var db=mydbname --db-var user=root --db-var password=123`
- `--plugin`<br> List of plugins to be loaded. Module names to import must be provided.
  <br>Example:
  - `--plugin=myplugin1 --plugin=myplugin2`
- `--dbms`<br> The Database Management System name if it is not mentioned in the state config.
  <br>Example:
  - `--dbms=postgres`
- `--wsl`<br> Pass true if DbAsCode is run under Windows but PostgreSQL client should be run under WSL.
  <br>Example:
  - `--wsl=1`
- `--output` _plan only_<br> Specifies file name to store the migration plan. 
  <br>Example: 
  - `--output=/var/plan.json`
- `--source` _migrate only_<br> Specifies the source file to be used for plan creation if no plan is passed for the migration. 
  <br>Example:
  - `--source=/my-project/db.yml`
- `--plan` _migrate only_<br> Specifies the plan file generated by the `plan` command and saved with the `--output` option. Determine changes to be made in the DB. 
  <br>Example:
  - `--plan=/var/plan.json`

**Docker Note**: Keep in mind that all paths are valid inside the container only. To work
with files on your host machine you should mount local directories/files. This will be 
described below.

#### Environment Variables

If PgAsCode will not find CLI options passed it will look for options in environment variables. Options are passed using 
the `DBAC_` variable name prefix and an option name in uppercase (hyphens are replaced by underscores):

```shell script
$ docker run -e DBAC_DB_VAR="host=some.host|port=5432|password=123" -e DBAC_DBMS=postgres -e DBAC_PLAN=/var/plan.json pgascode migrate
```

Options `--plugins` and `--db-var` should be passed as single variables with list values separated by the `|` character.

#### Docker and files on the host

To allow a container working with files on the host you should mount directories to the container and point
command line options to the mounted paths. Example:

```shell script
$ docker run -e DBAC_DB_VAR="host=some.host|port=5432|password=123" -v /my-project/config:/source -v /my-project/output:/output pgascode plan /source/db.yml --output=/output/plan.json
$ docker run -e DBAC_DB_VAR="host=some.host|port=5432|password=123" -v /my-project/output:/output pgascode migrate --plan=/output/plan.json
```

This example assumes the following:

- `/my-project` - your project directory on the host.
- `/my-project/config/db.yml` - location of the DbAsCode configuration on the host.
- `/my-project/output` - directory on the host where DbAsCode plan will be saved.
- `/source` - directory in the container where the host directory `/my-project/config` is mounted making the container's path `/source/db.yml` pointing to the `/my-project/config/db.yml`.
- `/output` - directory in the container where the host directory `/my-project/output` is mounted and where DbAsCode will save the plan. Plan will be available by the `/my-project/output/plan.json` path.

## Configuration

State configuration is written in Yaml files to allow convenient readability by humans.

DbAsCode is plugin-driven and most of the functionality is implemented in plugins. There are some very 
basic common configuration options.

The configuration consists of DbObjects and their properties. Properties can contain scalars, arrays, objects, 
and other DbObjects. For example, a table may contain some scalar properties like table comment and default encoding.
It also contains a list of columns. In this case, we can represent the table as an instance of a DbObject with scalar 
properties `comment` and `encoding`, and with an array property `columns` which contains columns (which are also 
DbObject instances).

The following options are common for DB objects:

Option | Type | Description
-------|------|------------
`comment` | `string` | Defines text comment for the object.
`extends` | `string` | Defines the object name to extend. There are no base extension functionality. Each plugin must implement its own logic of what exactly an object inherits from an ancestor. 
`grant` | `<permission_object>` | Defines permissions to grant to the object.
`revoke` | `<permission_object>` | Defines permissions to revoke from the object.

The `permission_object` format:

```text
{
  grant | revoke: {
    <operation_name>: <role name> | <role name>[]
  }
}
```

- `operation_name` - the name of operation granted or revoked for a user or role. Examples: `all`, `select`, `update`, `execute`, etc.
- `role name` - string name of a role or a user. You can pass either a single role name or an array of roles.

All objects describing databases itself (root state config objects) also have the following options:

Option | Type | Description
-------|------|------------
`dbms` | `string` | The name of the database management system. It is used to match a proper plugin to handle the configuration. Either configuration value or CLI option or environment variable must be provided.
`dbms_version` | `number` | Defines the database engine version. Should be used by a plugin for proper configuration verifications and migrations depending on the version.


Please read documentation of the following plugins to get what options they allow to use:

- Database engines
  - [PostgreSQL](src/plugins/db-postgres/README.md) (built-in)
  - PostgreSQL plugins
    - [RowLevelSecurity](src/plugins/tools-postgres-rls/README.md) (built-in) - Manage row-level security on tables.
    - [Postgraphile](src/plugins/tools-postgres-postgraphile/README.md) (built-in) - Add support for some [Postgraphile](https://www.graphile.org/postgraphile/) features.
    - [DefaultRows](src/plugins/tools-postgres-default-rows/README.md) (built-in) - Define default rows automatically inserted on table creation.

Built-in plugins are loaded automatically.

<a name="Operators"></a>
### Operators in values 

You can use the following operators to substitute dynamic values:

- `$include <yaml path>`<br>Parse the specified Yaml file and set it's content as the value. File path is relative to the file where this operator is used.<br>Example:
  ```yaml
  tables:
    account: $include schema/account.yml
    account_type: $include schema/account_type.yml
  ```
- `$file <file path>`<br>Reads the specified file and set it's content as the string value. File path is relative to the file where this operator is used. <br>Example:
  ```yaml
  functions:
    acl_check:
      language: plpgsql
      code: $file functions/acl_check.sql
  ```
- `${parameterValue}`<br>Search for dynamic value and place it's value as raw value (no type checking and quotation is applied). Values are defined in plugins. <br>Example: 
  ```yaml
    tables:
      user:
        columns:
          user_type: ${schemaName}.user_type
  ```

## Examples

PostgreSQL:

```yaml
dbms: postgresql
dbms_version: 12
extensions:
  - plv8
roles: 
    sys_all:
    sys_admin:
      member_of: sys_all
      is_client: true
    sys_user:
      member_of: sys_all
      is_client: true
    sys_anonymous:
      member_of: sys_all
      is_client: true
schemas:
  app-public:
    tables:
      base_table:
        comment: 'Base table for all other tables'
        columns:
          id:
            type: bigint
            autoincrement: true
      
      user:
        comment: 'Users in the system'
        extends: base_table
        columns:
          name:
            type: text
          email:
            type: text
            allow_null: true
          registreded_at:
            type: timestamp with time zone
            default:
              value: now()
              raw: true
        indexes:
          - name
        unique_keys:
          - email
        grant:
          select: [sys_user, sys_admin]
          insert: [sys_admin]
        revoke: 
          all: sys_anonymous
```

## Plugins development

[See plugins development documentation](PLUGIN-DEV.md).

## API

[See the API docs](API.md).

## License

[MIT](LICENSE.md)
